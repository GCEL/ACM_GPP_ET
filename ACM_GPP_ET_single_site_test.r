###
## function to return x,y coordinate from an array which is nearest to a provided lat / long value
###

closest2d <- function (id,lat,long,lat_in,long_in,nos_dim) {

    # extract needed lat / long
    lat1=lat_in[id] ; long1=long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R=6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad=pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

    if (nos_dim == 1) {
	## lat long are in single vectors repeating i.e. lat[1:10]=89.9,89.9,89.9... ; long[1:10]=-180,-160,-140....
	# loop through to find the smallest distance
	d_old=1e6
	# check for locations which exactly coincide, complete calculatuion and finally remove NaN generated by value "1"
	d = acos(sin(lat1*deg_to_rad)*sin(lat*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
	match = which(is.na(d) == TRUE) ; d[match] = 0 #; print(match)
	d = pmax(1e-6,d,na.rm=TRUE)
	output=which(d == min(d))[1] ; d_old=d[output] 
	#if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
	rm(d_old)
    } else if (nos_dim == 2) {
	## lat and long are in two - dimensional arrays which co-varying 
	# loop through to find the smallest distance
	d = sin(lat1*deg_to_rad)*sin(as.vector(lat)*deg_to_rad)+cos(lat1*deg_to_rad)*cos(as.vector(lat)*deg_to_rad)*cos((as.vector(long)*deg_to_rad)-(long1*deg_to_rad))
	# check for locations which exactly coincide, complete calculatuion and finally remove NaN generated by value "1"
        d = acos(d)*R ; match = which(is.na(d) == TRUE) ; d[match] = 0 #; print(match)
	#if (min(d) > 10) {print(paste("id = ",id," Minimum distance found (",round(min(d),digits=1),") is greater than 10 km from actual location"))}
	i=ceiling(which(d == min(d))/dim(lat)[1])
	j=which(d == min(d))-floor(which(d == min(d))/dim(lat)[1])*dim(lat)[1]
	output = list(j[1],i[1]) ; rm(i,j)
    } else if (nos_dim == 3) {
	## lat and long are in two 1-dimensional vectors but co-varying as in cartesian co-ordinates
	# loop through to find the smallest distance
	d_old=1e6
	for (j in seq(1, length(lat))) {
	    # convert all to radians
	    d = acos(sin(lat1*deg_to_rad)*sin(lat[j]*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat[j]*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
	    if (min(d) < d_old) {
		possible_i = which(d == min(d))
#print(possible_i) ; print(j) ; print(length(long)) ; print(length(lat))
		if (length(possible_i) > 1 & possible_i[1] == 1 & possible_i[length(possible_i)] == length(long)) {
		    possible_i = possible_i[which(long[possible_i] == long1)]
		} 
		output = list(possible_i[1],j) ; d_old=min(d)
	    }
	} # j loop
	#if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
	rm(i,d_old)
    }

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function

###
## Create needed ACM_GPP_ET shared object

# set to the working directory that this script should be called from
setwd("/Users/lsmallma/WORK/R/PDRA/Scripts/ACM_GPP_ET/") ; wkdir = getwd()
# compile the shared object containing ACM_GPP and ACM_ET
system("gfortran ./src/ACM_GPP_ET.f90 ./src/ACM_GPP_ET_R_interface.f90 -o ./src/acm_gpp_et.so -fPIC -shared")
system("mv ./src/acm_gpp_et.so .")

###
## Borrow met data from an existing CARDAMOM analysis

drivers = read.csv("./forest_drivers.csv")

###
## Define our output variables based on the grid of the CARDAMOM analysis we are borrowing

mean_lai = array(NA, dim=c(dim(drivers)[1]))
mean_gpp = array(NA, dim=c(dim(drivers)[1]))
mean_transpiration = array(NA, dim=c(dim(drivers)[1]))
mean_wetcanopyevap = array(NA, dim=c(dim(drivers)[1]))
mean_soilevaporation = array(NA, dim=c(dim(drivers)[1]))
mean_rootwatermm = array(NA, dim=c(dim(drivers)[1]))
mean_WUE = array(NA, dim=c(dim(drivers)[1]))
mean_wSWP = array(NA, dim=c(dim(drivers)[1]))

###
## Some ACM_GPP_ET parameters

output_dim=7 ; nofluxes = 4 ; nopools = 1 ; nopars = 4 ; nos_iter = 1
#soils_data=read.csv("/home/lsmallma/gcel/HWSD/processed_file/HWSD_sand_silt_clay_orgfrac_vector_with_lat_long_200.csv",header=TRUE)

n=1
     if (n%%1000 == 0){print(paste("...beginning site:",n," of ",dim(drivers)[1], sep=""))}

     # met note that the dimension here are different to that of drivers$met
     met=array(-9999,dim=c(length(drivers$MINT_oC),12))
     met[,1] = 1:length(drivers$MINT_oC)  # day of analysis
     met[,2] = drivers$MINT_oC  # min temperature (oC)
     met[,3] = drivers$MAXT_oC  # max temperature (oC)
     met[,4] = drivers$RAD_MJ_DAY  # SW Radiation (MJ.m-2.day-1)
     met[,5] = 400  # CO2 ppm
     met[,6] = drivers$DOY  # day of year
     met[,7] = 0.1/(24*60*60)  # rainfall (kg.m-2.day-1 -> kg.m-2.s-1)
     met[,8] = 0.5*(drivers$MAXT_oC+drivers$MINT_oC) # avg temperature (oC)
     met[,9] = 3.23 # avg wind speed (m.s-1)
     met[,10]= 2000 # avg VPD (kPa->Pa)
     # ecosystem state drivers now rather than meteorology
     met[,11]= 2.5#drivers$lai[n] # LAI
     met[,12]= 100#drivers$lai[n]*80 #100  # root C stocks
     # parameters
     parameters = array(NA, dim=c(nopars,nos_iter))
     parameters[1,] = 1.89  # foliar N (gN.m-2)
     parameters[2,] = -9999 # min leaf water potential (MPa)
     parameters[3,] = 100   # root biomass needed to reach 50 % depth
     parameters[4,] = 2   # max root depth (m)

     # other inputs
     lat = 49
     # search location of soils data
#     i1=unlist(closest2d(1,soils_data$lat_wanted,soils_data$long_wanted,drivers$lat[n],drivers$long[n],1))[1]
#     soil_info=c(pmax(1,soils_data$sand_top[i1]),pmax(1,soils_data$sand_bot[i1]),pmax(1,soils_data$clay_top[i1]),pmax(1,soils_data$clay_bot[i1]) )
#     if (soil_info[2] == 1) {soil_info[2] = soil_info[1]}
#     if (soil_info[4] == 1) {soil_info[4] = soil_info[3]}
     soil_info=c(40,40,15,15)
        if (is.loaded("racmgppet") == FALSE) { dyn.load("./acm_gpp_et.so") }
        tmp=.Fortran("racmgppet",output_dim=as.integer(output_dim),met=as.double(t(met)),pars=as.double(parameters)
                                ,out_var=as.double(array(0,dim=c(nos_iter,(dim(met)[1]),output_dim)))
                                ,lat=as.double(lat),nopars=as.integer(nopars),nomet=as.integer(dim(met)[2])
                                ,nofluxes=as.integer(nofluxes),nopools=as.integer(nopools)
                                ,nodays=as.integer(dim(met)[1])
                                ,deltat=as.double(array(0,dim=c(as.integer(dim(met)[1])))),nos_iter=as.integer(nos_iter)
                                ,soil_frac_clay=as.double(array(c(soil_info[3],soil_info[4],soil_info[4]),dim=c(3)))
                                ,soil_frac_sand=as.double(array(c(soil_info[1],soil_info[2],soil_info[2]),dim=c(3))) )
        output=tmp$out_var ; output=array(output, dim=c(nos_iter,(dim(met)[1]),output_dim))
        if (n == dim(drivers)[1]) {dyn.unload("./acm_gpp_et.so")}
        rm(tmp) ; gc()

     # assign outputs to out final grids
     mean_lai = (output[1,,1]) # lai
     mean_gpp = (output[1,,2]) # GPP (gC.m-2.day-1)
     mean_transpiration = (output[1,,3])   # transpiration (kg.m-2.day-1)
     mean_wetcanopyevap = (output[1,,4])   # wetcanopy evaporation (kg.m-2.day-1)
     mean_soilevaporation = (output[1,,5]) # soil evaporation (kg.m-2.day-1)
     mean_wSWP = (output[1,,6])            # weighted soil water potential (MPa)
     mean_WUE = mean_gpp/mean_transpiration # water use efficiency (gC/kgH2O)
     mean_rootwatermm = (output[1,,7])     # water in rooting zone (mm)


fig_height=4000 ; fig_width=7200
jpeg(file="./FIGURES/figure_4.jpg", height=fig_height, width=fig_width, res=400, quality=100)
par(mfrow=c(2,3), mar=c(5.4,5.2, 6.4, 6.5), omi=c(0.2, 0.2, 0.2, 0.40))
plot(mean_gpp~mean_wSWP,main="", ylab="GPP", xlab="wSWP",pch=16)
plot(mean_gpp~mean_soilevaporation,main="", ylab="GPP", xlab="Rtot",pch=16)
plot(mean_gpp~mean_rootwatermm,main="", ylab="GPP", xlab="Root water",pch=16)
plot(mean_wSWP~mean_soilevaporation, main="", ylab="wSWP", xlab="Rtot", pch=16)
plot(mean_rootwatermm~mean_soilevaporation,main="", ylab="Rootwater", xlab="Rtot",pch=16)
plot(0.5*(drivers$MAXT_oC+drivers$MINT_oC)~mean_soilevaporation, main="", ylab="meant", xlab="Rtot", pch=16)
dev.off()

jpeg(file="./FIGURES/figure_5.jpg", height=fig_height, width=fig_width, res=400, quality=100)
par(mfrow=c(2,3), mar=c(5.4,5.2, 6.4, 6.5), omi=c(0.2, 0.2, 0.2, 0.40))
plot(mean_gpp,main="GPP", ylab="", xlab="",pch=16)
plot(mean_soilevaporation,main="Rtot", ylab="", xlab="",pch=16)
plot(mean_rootwatermm,main="Root water", ylab="", xlab="",pch=16)
plot(mean_wSWP,main="wSWP", ylab="", xlab="",pch=16)
plot(mean_transpiration, main="Transpiration", ylab="",xlab="", pch=16)
plot(mean_gpp~mean_transpiration,main="", ylab="GPP", xlab="Transpiration",pch=16)
dev.off()

print(round(mean(mean_gpp/mean_transpiration),digits=2))
